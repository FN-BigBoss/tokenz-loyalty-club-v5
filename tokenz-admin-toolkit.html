
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TokenZ Admin Utilities v5.1</title>
    <style>
        /* This module contains utility functions for the TokenZ Admin System */
        .utility-module { display: none; }
    </style>
</head>
<body class="utility-module">
    <script>
        // TokenZ Admin Utilities Module v5.1
        // Utility functions separated from main admin interface for maintainability
        
        console.log('üîß Loading TokenZ Admin Utilities v5.1...');
        
        // ==========================================
        // DATA STRUCTURE DEFINITIONS
        // ==========================================
        
        window.AdminUtilities = {
            // Default data structure with new v5.1 features
            getDefaultDataStructure: function() {
                return {
                    merchants: [],
                    products: [],
                    users: [],
                    ratings: [], // New: centralized ratings system
                    categories: {
                        merchant: [
                            "Food & Beverage", "Fitness & Health", "Home & Utilities", "Transportation",
                            "Entertainment & Media", "Personal Care & Beauty", "Professional Services",
                            "Technology & Software", "Education & Learning", "Financial Services",
                            "Retail & Shopping", "Travel & Hospitality", "Security & Safety", "Pet Care",
                            "Automotive", "Real Estate", "Insurance", "Telecommunications",
                            "Energy & Environment", "Other"
                        ],
                        product: [
                            "Coffee & Tea", "Food & Meals", "Beverages", "Snacks & Treats",
                            "Gym Memberships", "Personal Training", "Wellness Services", "Beauty Treatments",
                            "Streaming Services", "Gaming Subscriptions", "Music & Audio", "Books & Magazines",
                            "Software Subscriptions", "Cloud Storage", "VPN Services", "Productivity Tools",
                            "Home Security", "Utilities", "Internet & Phone", "Transportation Passes",
                            "Car Services", "Insurance Plans", "Financial Services", "Educational Courses",
                            "Professional Development", "Pet Supplies", "Pet Services", "Clothing & Accessories",
                            "Home Goods", "Electronics", "Other"
                        ]
                    },
                    recentActivity: [],
                    systemSettings: {
                        currency: 'ZAR',
                        systemName: 'TokenZ Loyalty Club',
                        adminEmail: 'admin@tokenzclub.com',
                        featuredProductDuration: 30, // days
                        maxRatingValue: 5,
                        allowAnonymousRatings: false
                    }
                };
            },
            
            // ==========================================
            // DATA MIGRATION & COMPATIBILITY
            // ==========================================
            
            migrateDataToV51: function(data) {
                console.log('üîÑ Migrating data to v5.1 format...');
                
                // Ensure all required collections exist
                if (!data.ratings) data.ratings = [];
                if (!data.systemSettings) data.systemSettings = this.getDefaultDataStructure().systemSettings;
                
                // Migrate products to include new rating fields
                if (data.products) {
                    data.products.forEach(product => {
                        if (typeof product.featured === 'undefined') product.featured = false;
                        if (!product.featuredExpiry) product.featuredExpiry = null;
                        if (typeof product.averageRating === 'undefined') product.averageRating = 0;
                        if (!product.totalRatings) product.totalRatings = 0;
                        if (!product.ratingBreakdown) {
                            product.ratingBreakdown = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
                        }
                    });
                }
                
                // Migrate users to include follow system
                if (data.users) {
                    data.users.forEach(user => {
                        if (!user.followedMerchants) user.followedMerchants = [];
                        if (!user.ratingsGiven) user.ratingsGiven = [];
                    });
                }
                
                // Migrate merchants to include follower tracking
                if (data.merchants) {
                    data.merchants.forEach(merchant => {
                        if (typeof merchant.followerCount === 'undefined') merchant.followerCount = 0;
                        if (!merchant.followers) merchant.followers = [];
                    });
                }
                
                console.log('‚úÖ Data migration to v5.1 complete');
                return data;
            },
            
            // ==========================================
            // RATING SYSTEM UTILITIES
            // ==========================================
            
            addRating: function(adminData, ratingData) {
                const rating = {
                    id: this.generateId(adminData.ratings),
                    userId: ratingData.userId,
                    productId: ratingData.productId,
                    merchantId: ratingData.merchantId,
                    rating: Math.max(1, Math.min(5, parseInt(ratingData.rating))), // Ensure 1-5 range
                    review: ratingData.review || '',
                    date: new Date().toISOString(),
                    status: 'active', // active, hidden, flagged
                    helpful: 0, // helpful votes
                    reported: 0 // report count
                };
                
                // Check if user already rated this product
                const existingRatingIndex = adminData.ratings.findIndex(r => 
                    r.userId === rating.userId && r.productId === rating.productId
                );
                
                if (existingRatingIndex >= 0) {
                    // Update existing rating
                    const oldRating = adminData.ratings[existingRatingIndex];
                    adminData.ratings[existingRatingIndex] = { ...oldRating, ...rating, id: oldRating.id };
                    console.log('üìù Updated existing rating');
                } else {
                    // Add new rating
                    adminData.ratings.push(rating);
                    console.log('‚≠ê Added new rating');
                }
                
                // Update product rating statistics
                this.updateProductRatingStats(adminData, rating.productId);
                
                return rating;
            },
            
            updateProductRatingStats: function(adminData, productId) {
                const product = adminData.products.find(p => p.id === productId);
                if (!product) return;
                
                const productRatings = adminData.ratings.filter(r => 
                    r.productId === productId && r.status === 'active'
                );
                
                if (productRatings.length === 0) {
                    product.averageRating = 0;
                    product.totalRatings = 0;
                    product.ratingBreakdown = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
                    return;
                }
                
                // Calculate average rating
                const totalScore = productRatings.reduce((sum, r) => sum + r.rating, 0);
                product.averageRating = Math.round((totalScore / productRatings.length) * 10) / 10;
                product.totalRatings = productRatings.length;
                
                // Calculate rating breakdown
                product.ratingBreakdown = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
                productRatings.forEach(r => {
                    product.ratingBreakdown[r.rating]++;
                });
                
                console.log(`üìä Updated rating stats for product ${productId}: ${product.averageRating}/5 (${product.totalRatings} ratings)`);
            },
            
            deleteRating: function(adminData, ratingId) {
                const ratingIndex = adminData.ratings.findIndex(r => r.id === ratingId);
                if (ratingIndex >= 0) {
                    const rating = adminData.ratings[ratingIndex];
                    adminData.ratings.splice(ratingIndex, 1);
                    this.updateProductRatingStats(adminData, rating.productId);
                    console.log('üóëÔ∏è Rating deleted');
                    return true;
                }
                return false;
            },
            
            moderateRating: function(adminData, ratingId, status) {
                const rating = adminData.ratings.find(r => r.id === ratingId);
                if (rating) {
                    rating.status = status; // active, hidden, flagged
                    this.updateProductRatingStats(adminData, rating.productId);
                    console.log(`üõ°Ô∏è Rating ${ratingId} status changed to ${status}`);
                    return true;
                }
                return false;
            },
            
            // ==========================================
            // FEATURED PRODUCTS UTILITIES
            // ==========================================
            
            setProductFeatured: function(adminData, productId, featured = true, durationDays = 30) {
                const product = adminData.products.find(p => p.id === productId);
                if (!product) return false;
                
                product.featured = featured;
                if (featured) {
                    const expiryDate = new Date();
                    expiryDate.setDate(expiryDate.getDate() + durationDays);
                    product.featuredExpiry = expiryDate.toISOString();
                    console.log(`‚≠ê Product ${productId} featured until ${expiryDate.toLocaleDateString()}`);
                } else {
                    product.featuredExpiry = null;
                    console.log(`üìå Product ${productId} unfeatured`);
                }
                
                return true;
            },
            
            checkExpiredFeaturedProducts: function(adminData) {
                const now = new Date();
                let expiredCount = 0;
                
                adminData.products.forEach(product => {
                    if (product.featured && product.featuredExpiry) {
                        const expiryDate = new Date(product.featuredExpiry);
                        if (now > expiryDate) {
                            product.featured = false;
                            product.featuredExpiry = null;
                            expiredCount++;
                        }
                    }
                });
                
                if (expiredCount > 0) {
                    console.log(`‚è∞ ${expiredCount} featured products expired`);
                }
                
                return expiredCount;
            },
            
            getFeaturedProducts: function(adminData, merchantId = null) {
                this.checkExpiredFeaturedProducts(adminData);
                
                return adminData.products.filter(product => {
                    const isFeatured = product.featured && 
                                     product.featuredExpiry && 
                                     new Date(product.featuredExpiry) > new Date();
                    
                    if (merchantId) {
                        return isFeatured && product.merchantId === merchantId;
                    }
                    
                    return isFeatured;
                });
            },
            
            // ==========================================
            // FOLLOW SYSTEM UTILITIES
            // ==========================================
            
            followMerchant: function(adminData, userId, merchantId) {
                const user = adminData.users.find(u => u.id === userId);
                const merchant = adminData.merchants.find(m => m.id === merchantId);
                
                if (!user || !merchant) return false;
                
                if (!user.followedMerchants.includes(merchantId)) {
                    user.followedMerchants.push(merchantId);
                    merchant.followers.push(userId);
                    merchant.followerCount = merchant.followers.length;
                    console.log(`üë• User ${userId} now follows merchant ${merchantId}`);
                    return true;
                }
                
                return false; // Already following
            },
            
            unfollowMerchant: function(adminData, userId, merchantId) {
                const user = adminData.users.find(u => u.id === userId);
                const merchant = adminData.merchants.find(m => m.id === merchantId);
                
                if (!user || !merchant) return false;
                
                const userIndex = user.followedMerchants.indexOf(merchantId);
                const merchantIndex = merchant.followers.indexOf(userId);
                
                if (userIndex >= 0) {
                    user.followedMerchants.splice(userIndex, 1);
                }
                
                if (merchantIndex >= 0) {
                    merchant.followers.splice(merchantIndex, 1);
                    merchant.followerCount = merchant.followers.length;
                }
                
                console.log(`üëã User ${userId} unfollowed merchant ${merchantId}`);
                return true;
            },
            
            getMerchantFollowers: function(adminData, merchantId) {
                const merchant = adminData.merchants.find(m => m.id === merchantId);
                if (!merchant) return [];
                
                return adminData.users.filter(user => 
                    user.followedMerchants && user.followedMerchants.includes(merchantId)
                );
            },
            
            getUserFollowedMerchants: function(adminData, userId) {
                const user = adminData.users.find(u => u.id === userId);
                if (!user || !user.followedMerchants) return [];
                
                return adminData.merchants.filter(merchant => 
                    user.followedMerchants.includes(merchant.id)
                );
            },
            
            // ==========================================
            // PERMISSION & ROLE UTILITIES
            // ==========================================
            
            checkUserPermission: function(user, requiredRole) {
                if (!user || !user.role) return false;
                
                const roleHierarchy = {
                    'admin': 3,
                    'merchant': 2,
                    'member': 1
                };
                
                const userLevel = roleHierarchy[user.role] || 0;
                const requiredLevel = roleHierarchy[requiredRole] || 0;
                
                return userLevel >= requiredLevel;
            },
            
            canUserManageProduct: function(user, product) {
                if (!user || !product) return false;
                
                // Admins can manage all products
                if (user.role === 'admin') return true;
                
                // Merchants can only manage their own products
                if (user.role === 'merchant') {
                    const merchant = this.findMerchantByUserId(user.id);
                    return merchant && product.merchantId === merchant.id;
                }
                
                return false;
            },
            
            findMerchantByUserId: function(adminData, userId) {
                // This assumes merchants have a userId field linking to users table
                return adminData.merchants.find(m => m.userId === userId);
            },
            
            // ==========================================
            // DATA VALIDATION UTILITIES
            // ==========================================
            
            validateRatingData: function(ratingData) {
                const errors = [];
                
                if (!ratingData.userId) errors.push('User ID is required');
                if (!ratingData.productId) errors.push('Product ID is required');
                if (!ratingData.merchantId) errors.push('Merchant ID is required');
                if (!ratingData.rating || ratingData.rating < 1 || ratingData.rating > 5) {
                    errors.push('Rating must be between 1 and 5');
                }
                if (ratingData.review && ratingData.review.length > 1000) {
                    errors.push('Review must be less than 1000 characters');
                }
                
                return {
                    isValid: errors.length === 0,
                    errors: errors
                };
            },
            
            validateProductData: function(productData) {
                const errors = [];
                
                if (!productData.name || productData.name.trim().length === 0) {
                    errors.push('Product name is required');
                }
                if (!productData.merchantId) errors.push('Merchant ID is required');
                if (!productData.shortDescription || productData.shortDescription.trim().length === 0) {
                    errors.push('Short description is required');
                }
                if (productData.shortDescription && productData.shortDescription.length > 100) {
                    errors.push('Short description must be 100 characters or less');
                }
                if (!productData.price || productData.price <= 0) {
                    errors.push('Price must be greater than 0');
                }
                if (!productData.category) errors.push('Category is required');
                
                return {
                    isValid: errors.length === 0,
                    errors: errors
                };
            },
            
            // ==========================================
            // SEARCH & FILTER UTILITIES
            // ==========================================
            
            searchProducts: function(adminData, searchTerm, filters = {}) {
                let results = adminData.products;
                
                // Text search
                if (searchTerm) {
                    const term = searchTerm.toLowerCase();
                    results = results.filter(product => 
                        product.name.toLowerCase().includes(term) ||
                        (product.shortDescription && product.shortDescription.toLowerCase().includes(term)) ||
                        (product.longDescription && product.longDescription.toLowerCase().includes(term))
                    );
                }
                
                // Apply filters
                if (filters.merchantId) {
                    results = results.filter(p => p.merchantId === filters.merchantId);
                }
                
                if (filters.category) {
                    results = results.filter(p => p.category === filters.category);
                }
                
                if (filters.status) {
                    results = results.filter(p => p.status === filters.status);
                }
                
                if (filters.featured !== undefined) {
                    results = results.filter(p => p.featured === filters.featured);
                }
                
                if (filters.minRating) {
                    results = results.filter(p => p.averageRating >= filters.minRating);
                }
                
                if (filters.priceRange) {
                    results = results.filter(p => 
                        p.price >= filters.priceRange.min && p.price <= filters.priceRange.max
                    );
                }
                
                return results;
            },
            
            searchMerchants: function(adminData, searchTerm, filters = {}) {
                let results = adminData.merchants;
                
                // Text search
                if (searchTerm) {
                    const term = searchTerm.toLowerCase();
                    results = results.filter(merchant => 
                        merchant.name.toLowerCase().includes(term) ||
                        (merchant.description && merchant.description.toLowerCase().includes(term)) ||
                        (merchant.category && merchant.category.toLowerCase().includes(term))
                    );
                }
                
                // Apply filters
                if (filters.category) {
                    results = results.filter(m => m.category === filters.category);
                }
                
                if (filters.status) {
                    results = results.filter(m => m.status === filters.status);
                }
                
                if (filters.hasFollowers) {
                    results = results.filter(m => m.followerCount > 0);
                }
                
                return results;
            },
            
            // ==========================================
            // STATISTICS & ANALYTICS UTILITIES
            // ==========================================
            
            getSystemStats: function(adminData) {
                this.checkExpiredFeaturedProducts(adminData);
                
                const stats = {
                    merchants: {
                        total: adminData.merchants.length,
                        active: adminData.merchants.filter(m => m.status === 'active').length,
                        withFollowers: adminData.merchants.filter(m => m.followerCount > 0).length
                    },
                    products: {
                        total: adminData.products.length,
                        active: adminData.products.filter(p => p.status === 'active').length,
                        featured: adminData.products.filter(p => p.featured).length,
                        withRatings: adminData.products.filter(p => p.totalRatings > 0).length
                    },
                    users: {
                        total: adminData.users.length,
                        active: adminData.users.filter(u => u.status === 'active').length,
                        withFollows: adminData.users.filter(u => u.followedMerchants && u.followedMerchants.length > 0).length
                    },
                    ratings: {
                        total: adminData.ratings.length,
                        active: adminData.ratings.filter(r => r.status === 'active').length,
                        flagged: adminData.ratings.filter(r => r.status === 'flagged').length,
                        averageRating: this.calculateOverallAverageRating(adminData)
                    }
                };
                
                return stats;
            },
            
            calculateOverallAverageRating: function(adminData) {
                const activeRatings = adminData.ratings.filter(r => r.status === 'active');
                if (activeRatings.length === 0) return 0;
                
                const totalScore = activeRatings.reduce((sum, r) => sum + r.rating, 0);
                return Math.round((totalScore / activeRatings.length) * 10) / 10;
            },
            
            getMerchantStats: function(adminData, merchantId) {
                const merchant = adminData.merchants.find(m => m.id === merchantId);
                if (!merchant) return null;
                
                const merchantProducts = adminData.products.filter(p => p.merchantId === merchantId);
                const merchantRatings = adminData.ratings.filter(r => r.merchantId === merchantId && r.status === 'active');
                
                return {
                    merchant: merchant,
                    products: {
                        total: merchantProducts.length,
                        active: merchantProducts.filter(p => p.status === 'active').length,
                        featured: merchantProducts.filter(p => p.featured).length
                    },
                    ratings: {
                        total: merchantRatings.length,
                        average: merchantRatings.length > 0 ? 
                                Math.round((merchantRatings.reduce((sum, r) => sum + r.rating, 0) / merchantRatings.length) * 10) / 10 : 0
                    },
                    followers: merchant.followerCount || 0
                };
            },
            
            // ==========================================
            // UTILITY FUNCTIONS
            // ==========================================
            
            generateId: function(collection = []) {
                if (collection.length === 0) return 1;
                return Math.max(...collection.map(item => item.id || 0)) + 1;
            },
            
            formatDate: function(dateString) {
                if (!dateString) return 'N/A';
                return new Date(dateString).toLocaleDateString();
            },
            
            formatDateTime: function(dateString) {
                if (!dateString) return 'N/A';
                return new Date(dateString).toLocaleString();
            },
            
            formatCurrency: function(amount, currency = 'ZAR') {
                const symbols = {
                    'ZAR': 'R',
                    'USD': '$',
                    'EUR': '‚Ç¨',
                    'GBP': '¬£'
                };
                
                const symbol = symbols[currency] || currency;
                return `${symbol}${amount.toFixed(2)}`;
            },
            
            generateStarRating: function(rating, maxRating = 5) {
                const fullStars = Math.floor(rating);
                const hasHalfStar = rating % 1 >= 0.5;
                const emptyStars = maxRating - fullStars - (hasHalfStar ? 1 : 0);
                
                return '‚òÖ'.repeat(fullStars) + 
                       (hasHalfStar ? '‚òÜ' : '') + 
                       '‚òÜ'.repeat(emptyStars);
            },
            
            truncateText: function(text, maxLength) {
                if (!text || text.length <= maxLength) return text;
                return text.substring(0, maxLength - 3) + '...';
            },
            
            sanitizeHtml: function(html) {
                const div = document.createElement('div');
                div.textContent = html;
                return div.innerHTML;
            },
            
            debounce: function(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },
            
            // ==========================================
            // EXPORT/IMPORT UTILITIES
            // ==========================================
            
            exportData: function(adminData, type = 'all') {
                const exportData = {
                    exported: new Date().toISOString(),
                    version: '5.1',
                    type: type
                };
                
                switch (type) {
                    case 'all':
                        Object.assign(exportData, adminData);
                        break;
                    case 'merchants':
                        exportData.merchants = adminData.merchants;
                        break;
                    case 'products':
                        exportData.products = adminData.products;
                        break;
                    case 'users':
                        exportData.users = adminData.users;
                        break;
                    case 'ratings':
                        exportData.ratings = adminData.ratings;
                        break;
                    case 'categories':
                        exportData.categories = adminData.categories;
                        break;
                }
                
                return exportData;
            },
            
            validateImportData: function(importData) {
                const errors = [];
                
                if (!importData.version) {
                    errors.push('Import file missing version information');
                }
                
                if (importData.merchants && !Array.isArray(importData.merchants)) {
                    errors.push('Merchants data must be an array');
                }
                
                if (importData.products && !Array.isArray(importData.products)) {
                    errors.push('Products data must be an array');
                }
                
                if (importData.users && !Array.isArray(importData.users)) {
                    errors.push('Users data must be an array');
                }
                
                if (importData.ratings && !Array.isArray(importData.ratings)) {
                    errors.push('Ratings data must be an array');
                }
                
                return {
                    isValid: errors.length === 0,
                    errors: errors
                };
            },
            
            // ==========================================
            // ACTIVITY LOGGING
            // ==========================================
            
            logActivity: function(adminData, type, description, userId = null) {
                const activity = {
                    id: this.generateId(adminData.recentActivity),
                    type: type, // merchant, product, user, rating, system
                    description: description,
                    userId: userId,
                    timestamp: new Date().toISOString()
                };
                
                adminData.recentActivity.unshift(activity);
                
                // Keep only last 50 activities
                if (adminData.recentActivity.length > 50) {
                    adminData.recentActivity = adminData.recentActivity.slice(0, 50);
                }
                
                console.log(`üìù Activity logged: ${description}`);
                return activity;
            },
            
            getRecentActivities: function(adminData, limit = 10, type = null) {
                let activities = adminData.recentActivity || [];
                
                if (type) {
                    activities = activities.filter(a => a.type === type);
                }
                
                return activities.slice(0, limit);
            }
        };
        
        // ==========================================
        // INITIALIZATION
        // ==========================================
        
        // Auto-migrate data when utilities are loaded
        window.AdminUtilities.autoMigrateData = function() {
            try {
                const stored = localStorage.getItem('tlc_admin_data');
                if (stored) {
                    const data = JSON.parse(stored);
                    const migratedData = this.migrateDataToV51(data);
                    localStorage.setItem('tlc_admin_data', JSON.stringify(migratedData));
                    console.log('‚úÖ Auto-migration completed');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Auto-migration failed:', error);
            }
        };
        
        // Run auto-migration when utilities load
        if (typeof window !== 'undefined') {
            window.AdminUtilities.autoMigrateData();
        }
        
        console.log('‚úÖ TokenZ Admin Utilities v5.1 loaded successfully');
        
        // Export for Node.js environments if needed
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = window.AdminUtilities;
        }
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'95e4019dd7d273c4',t:'MTc1MjM1OTY0OS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TokenZ Admin Utilities v5.1</title>
</head>
<body>
<script>
// TokenZ Admin Utilities Module v5.1
// This module contains utility functions for the admin system

// Enhanced data structure with new features
const AdminDataStructure = {
    merchants: [],
    products: [],
    users: [],
    ratings: [], // New: All ratings and reviews
    featuredProducts: [], // New: Featured product tracking
    userFollows: [], // New: User-merchant follow relationships
    categories: {
        merchant: [],
        product: []
    },
    recentActivity: []
};

// Rating and Review Management
const RatingUtils = {
    // Add a new rating
    addRating: function(userId, productId, rating, review = '') {
        const newRating = {
            id: this.generateRatingId(),
            userId: userId,
            productId: productId,
            merchantId: this.getProductMerchantId(productId),
            rating: rating,
            review: review.trim(),
            date: new Date().toISOString(),
            status: 'active', // active, hidden, flagged
            helpful: 0 // helpful votes
        };
        
        if (!window.adminData.ratings) {
            window.adminData.ratings = [];
        }
        
        window.adminData.ratings.push(newRating);
        this.updateProductRating(productId);
        return newRating;
    },
    
    // Update product average rating
    updateProductRating: function(productId) {
        const productRatings = window.adminData.ratings.filter(r => 
            r.productId === productId && r.status === 'active'
        );
        
        if (productRatings.length === 0) return;
        
        const average = productRatings.reduce((sum, r) => sum + r.rating, 0) / productRatings.length;
        const product = window.adminData.products.find(p => p.id === productId);
        
        if (product) {
            product.averageRating = Math.round(average * 10) / 10;
            product.ratingCount = productRatings.length;
        }
    },
    
    // Get product merchant ID
    getProductMerchantId: function(productId) {
        const product = window.adminData.products.find(p => p.id === productId);
        return product ? product.merchantId : null;
    },
    
    // Generate unique rating ID
    generateRatingId: function() {
        const existingIds = window.adminData.ratings ? window.adminData.ratings.map(r => r.id) : [];
        return Math.max(...existingIds, 0) + 1;
    },
    
    // Get ratings for a product
    getProductRatings: function(productId) {
        return window.adminData.ratings ? 
            window.adminData.ratings.filter(r => r.productId === productId) : [];
    },
    
    // Get ratings by a user
    getUserRatings: function(userId) {
        return window.adminData.ratings ? 
            window.adminData.ratings.filter(r => r.userId === userId) : [];
    },
    
    // Moderate rating (hide/show)
    moderateRating: function(ratingId, status) {
        const rating = window.adminData.ratings.find(r => r.id === ratingId);
        if (rating) {
            rating.status = status;
            this.updateProductRating(rating.productId);
        }
    },
    
    // Delete rating
    deleteRating: function(ratingId) {
        const ratingIndex = window.adminData.ratings.findIndex(r => r.id === ratingId);
        if (ratingIndex !== -1) {
            const rating = window.adminData.ratings[ratingIndex];
            window.adminData.ratings.splice(ratingIndex, 1);
            this.updateProductRating(rating.productId);
        }
    },
    
    // Generate star display HTML
    generateStarDisplay: function(rating, showNumber = true) {
        const fullStars = Math.floor(rating);
        const hasHalfStar = rating % 1 >= 0.5;
        const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);
        
        let html = '<div class="flex items-center space-x-1">';
        
        // Full stars
        for (let i = 0; i < fullStars; i++) {
            html += '<svg class="w-4 h-4 text-yellow-400 fill-current" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"/></svg>';
        }
        
        // Half star
        if (hasHalfStar) {
            html += '<svg class="w-4 h-4 text-yellow-400" viewBox="0 0 20 20"><defs><linearGradient id="half"><stop offset="50%" stop-color="currentColor"/><stop offset="50%" stop-color="transparent"/></linearGradient></defs><path fill="url(#half)" d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"/></svg>';
        }
        
        // Empty stars
        for (let i = 0; i < emptyStars; i++) {
            html += '<svg class="w-4 h-4 text-gray-300" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"/></svg>';
        }
        
        if (showNumber) {
            html += `<span class="text-sm text-gray-600 ml-1">(${rating.toFixed(1)})</span>`;
        }
        
        html += '</div>';
        return html;
    }
};

// Featured Products Management
const FeaturedUtils = {
    // Add product to featured list
    addFeatured: function(productId, expiryDays = 30) {
        const expiryDate = new Date();
        expiryDate.setDate(expiryDate.getDate() + expiryDays);
        
        const featured = {
            id: this.generateFeaturedId(),
            productId: productId,
            startDate: new Date().toISOString(),
            expiryDate: expiryDate.toISOString(),
            status: 'active',
            addedBy: 'admin' // Could be 'admin' or 'merchant'
        };
        
        if (!window.adminData.featuredProducts) {
            window.adminData.featuredProducts = [];
        }
        
        // Remove existing featured entry for this product
        window.adminData.featuredProducts = window.adminData.featuredProducts.filter(f => f.productId !== productId);
        
        // Add new featured entry
        window.adminData.featuredProducts.push(featured);
        
        // Update product featured status
        const product = window.adminData.products.find(p => p.id === productId);
        if (product) {
            product.featured = true;
            product.featuredExpiry = expiryDate.toISOString();
        }
        
        return featured;
    },
    
    // Remove product from featured list
    removeFeatured: function(productId) {
        window.adminData.featuredProducts = window.adminData.featuredProducts.filter(f => f.productId !== productId);
        
        const product = window.adminData.products.find(p => p.id === productId);
        if (product) {
            product.featured = false;
            product.featuredExpiry = null;
        }
    },
    
    // Check and clean expired featured products
    cleanExpiredFeatured: function() {
        const now = new Date();
        const expired = [];
        
        window.adminData.featuredProducts = window.adminData.featuredProducts.filter(featured => {
            const expiryDate = new Date(featured.expiryDate);
            if (expiryDate <= now) {
                expired.push(featured);
                
                // Update product status
                const product = window.adminData.products.find(p => p.id === featured.productId);
                if (product) {
                    product.featured = false;
                    product.featuredExpiry = null;
                }
                
                return false;
            }
            return true;
        });
        
        return expired;
    },
    
    // Get active featured products
    getActiveFeatured: function() {
        this.cleanExpiredFeatured();
        return window.adminData.featuredProducts.filter(f => f.status === 'active');
    },
    
    // Generate unique featured ID
    generateFeaturedId: function() {
        const existingIds = window.adminData.featuredProducts ? 
            window.adminData.featuredProducts.map(f => f.id) : [];
        return Math.max(...existingIds, 0) + 1;
    },
    
    // Get days remaining for featured product
    getDaysRemaining: function(featuredItem) {
        const now = new Date();
        const expiry = new Date(featuredItem.expiryDate);
        const diffTime = expiry - now;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return Math.max(0, diffDays);
    }
};

// User Follow System
const FollowUtils = {
    // Add user follow relationship
    addFollow: function(userId, merchantId) {
        if (!window.adminData.userFollows) {
            window.adminData.userFollows = [];
        }
        
        const existingFollow = window.adminData.userFollows.find(f => 
            f.userId === userId && f.merchantId === merchantId
        );
        
        if (!existingFollow) {
            window.adminData.userFollows.push({
                id: this.generateFollowId(),
                userId: userId,
                merchantId: merchantId,
                followDate: new Date().toISOString(),
                status: 'active'
            });
        }
    },
    
    // Remove user follow relationship
    removeFollow: function(userId, merchantId) {
        window.adminData.userFollows = window.adminData.userFollows.filter(f => 
            !(f.userId === userId && f.merchantId === merchantId)
        );
    },
    
    // Get followers for a merchant
    getMerchantFollowers: function(merchantId) {
        return window.adminData.userFollows ? 
            window.adminData.userFollows.filter(f => f.merchantId === merchantId && f.status === 'active') : [];
    },
    
    // Get merchants followed by user
    getUserFollows: function(userId) {
        return window.adminData.userFollows ? 
            window.adminData.userFollows.filter(f => f.userId === userId && f.status === 'active') : [];
    },
    
    // Check if user follows merchant
    isFollowing: function(userId, merchantId) {
        return window.adminData.userFollows ? 
            window.adminData.userFollows.some(f => 
                f.userId === userId && f.merchantId === merchantId && f.status === 'active'
            ) : false;
    },
    
    // Generate unique follow ID
    generateFollowId: function() {
        const existingIds = window.adminData.userFollows ? 
            window.adminData.userFollows.map(f => f.id) : [];
        return Math.max(...existingIds, 0) + 1;
    },
    
    // Get follower count for merchant
    getFollowerCount: function(merchantId) {
        return this.getMerchantFollowers(merchantId).length;
    }
};

// Permission and Role Management
const PermissionUtils = {
    // Check if current user has admin permissions
    isAdmin: function(user) {
        return user && user.role === 'admin';
    },
    
    // Check if current user has merchant permissions
    isMerchant: function(user) {
        return user && user.role === 'merchant';
    },
    
    // Check if current user can edit merchant
    canEditMerchant: function(user, merchantId) {
        if (this.isAdmin(user)) return true;
        if (this.isMerchant(user)) {
            // Merchants can only edit their own merchant profile
            return user.merchantId === merchantId;
        }
        return false;
    },
    
    // Check if current user can edit product
    canEditProduct: function(user, product) {
        if (this.isAdmin(user)) return true;
        if (this.isMerchant(user)) {
            // Merchants can only edit products for their merchant
            return user.merchantId === product.merchantId;
        }
        return false;
    },
    
    // Get merchant ID for current user
    getUserMerchantId: function(user) {
        if (this.isMerchant(user)) {
            return user.merchantId;
        }
        return null;
    },
    
    // Filter products by user permissions
    filterProductsByPermission: function(user, products) {
        if (this.isAdmin(user)) return products;
        if (this.isMerchant(user)) {
            return products.filter(p => p.merchantId === user.merchantId);
        }
        return [];
    },
    
    // Filter merchants by user permissions
    filterMerchantsByPermission: function(user, merchants) {
        if (this.isAdmin(user)) return merchants;
        if (this.isMerchant(user)) {
            return merchants.filter(m => m.id === user.merchantId);
        }
        return [];
    }
};

// Data Migration and Compatibility
const MigrationUtils = {
    // Migrate old data structure to new format
    migrateData: function(data) {
        console.log('üîÑ Migrating data to v5.1 format...');
        
        // Initialize new collections if they don't exist
        if (!data.ratings) data.ratings = [];
        if (!data.featuredProducts) data.featuredProducts = [];
        if (!data.userFollows) data.userFollows = [];
        
        // Migrate products to include rating fields
        data.products.forEach(product => {
            if (typeof product.averageRating === 'undefined') {
                product.averageRating = 0;
                product.ratingCount = 0;
            }
            if (typeof product.featured === 'undefined') {
                product.featured = false;
                product.featuredExpiry = null;
            }
        });
        
        // Migrate users to include follow relationships
        data.users.forEach(user => {
            if (!user.followedMerchants) {
                user.followedMerchants = [];
            }
            if (!user.role) {
                user.role = 'member';
            }
        });
        
        // Migrate merchants to include follower tracking
        data.merchants.forEach(merchant => {
            if (typeof merchant.followerCount === 'undefined') {
                merchant.followerCount = 0;
            }
        });
        
        console.log('‚úÖ Data migration complete');
        return data;
    },
    
    // Validate data integrity
    validateData: function(data) {
        const issues = [];
        
        // Check for orphaned ratings
        data.ratings.forEach(rating => {
            const product = data.products.find(p => p.id === rating.productId);
            const user = data.users.find(u => u.id === rating.userId);
            
            if (!product) issues.push(`Rating ${rating.id} references non-existent product ${rating.productId}`);
            if (!user) issues.push(`Rating ${rating.id} references non-existent user ${rating.userId}`);
        });
        
        // Check for orphaned featured products
        data.featuredProducts.forEach(featured => {
            const product = data.products.find(p => p.id === featured.productId);
            if (!product) issues.push(`Featured entry ${featured.id} references non-existent product ${featured.productId}`);
        });
        
        // Check for orphaned follows
        data.userFollows.forEach(follow => {
            const user = data.users.find(u => u.id === follow.userId);
            const merchant = data.merchants.find(m => m.id === follow.merchantId);
            
            if (!user) issues.push(`Follow ${follow.id} references non-existent user ${follow.userId}`);
            if (!merchant) issues.push(`Follow ${follow.id} references non-existent merchant ${follow.merchantId}`);
        });
        
        return issues;
    },
    
    // Clean orphaned data
    cleanOrphanedData: function(data) {
        console.log('üßπ Cleaning orphaned data...');
        
        // Remove orphaned ratings
        data.ratings = data.ratings.filter(rating => {
            const product = data.products.find(p => p.id === rating.productId);
            const user = data.users.find(u => u.id === rating.userId);
            return product && user;
        });
        
        // Remove orphaned featured products
        data.featuredProducts = data.featuredProducts.filter(featured => {
            const product = data.products.find(p => p.id === featured.productId);
            return product;
        });
        
        // Remove orphaned follows
        data.userFollows = data.userFollows.filter(follow => {
            const user = data.users.find(u => u.id === follow.userId);
            const merchant = data.merchants.find(m => m.id === follow.merchantId);
            return user && merchant;
        });
        
        console.log('‚úÖ Orphaned data cleaned');
        return data;
    }
};

// Export utilities to global scope
window.AdminUtils = {
    Rating: RatingUtils,
    Featured: FeaturedUtils,
    Follow: FollowUtils,
    Permission: PermissionUtils,
    Migration: MigrationUtils
};

console.log('‚úÖ Admin Utilities v5.1 loaded successfully');
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TokenZ Admin Utilities v5.1</title>
    <style>
        /* This module provides utility functions for the TokenZ Admin System */
        .utility-module { display: none; }
    </style>
</head>
<body class="utility-module">
    <script>
        // TokenZ Admin Utilities Module v5.1
        // Utility functions separated from main admin interface for better organization
        
        window.TokenZUtils = (function() {
            'use strict';
            
            // Data validation utilities
            const DataValidator = {
                validateEmail: function(email) {
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    return emailRegex.test(email);
                },
                
                validateUrl: function(url) {
                    try {
                        new URL(url);
                        return true;
                    } catch {
                        return false;
                    }
                },
                
                validatePrice: function(price) {
                    return !isNaN(price) && parseFloat(price) >= 0;
                },
                
                validateRating: function(rating) {
                    const num = parseInt(rating);
                    return !isNaN(num) && num >= 1 && num <= 5;
                },
                
                sanitizeText: function(text) {
                    if (!text) return '';
                    return text.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                              .replace(/[<>]/g, '');
                }
            };
            
            // Date utilities
            const DateUtils = {
                formatDate: function(dateString) {
                    if (!dateString) return 'N/A';
                    const date = new Date(dateString);
                    return date.toLocaleDateString('en-ZA', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    });
                },
                
                formatDateTime: function(dateString) {
                    if (!dateString) return 'N/A';
                    const date = new Date(dateString);
                    return date.toLocaleString('en-ZA', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                },
                
                getTimeAgo: function(dateString) {
                    if (!dateString) return 'Unknown';
                    const now = new Date();
                    const date = new Date(dateString);
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / (1000 * 60));
                    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                    
                    if (diffMins < 1) return 'Just now';
                    if (diffMins < 60) return `${diffMins} min${diffMins > 1 ? 's' : ''} ago`;
                    if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
                    if (diffDays < 30) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
                    return this.formatDate(dateString);
                },
                
                addDays: function(date, days) {
                    const result = new Date(date);
                    result.setDate(result.getDate() + days);
                    return result;
                },
                
                isExpired: function(dateString) {
                    if (!dateString) return false;
                    return new Date(dateString) < new Date();
                },
                
                getDaysUntilExpiry: function(dateString) {
                    if (!dateString) return null;
                    const expiry = new Date(dateString);
                    const now = new Date();
                    const diffTime = expiry - now;
                    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                }
            };
            
            // Rating utilities
            const RatingUtils = {
                calculateAverageRating: function(ratings) {
                    if (!ratings || ratings.length === 0) return 0;
                    const sum = ratings.reduce((acc, rating) => acc + rating.rating, 0);
                    return Math.round((sum / ratings.length) * 10) / 10; // Round to 1 decimal
                },
                
                generateStarDisplay: function(rating, maxStars = 5) {
                    const fullStars = Math.floor(rating);
                    const hasHalfStar = rating % 1 >= 0.5;
                    const emptyStars = maxStars - fullStars - (hasHalfStar ? 1 : 0);
                    
                    let stars = '';
                    for (let i = 0; i < fullStars; i++) stars += '‚òÖ';
                    if (hasHalfStar) stars += '‚òÜ';
                    for (let i = 0; i < emptyStars; i++) stars += '‚òÜ';
                    
                    return stars;
                },
                
                generateStarHTML: function(rating, showNumber = true, className = '') {
                    const stars = this.generateStarDisplay(rating);
                    const ratingText = showNumber ? ` (${rating})` : '';
                    return `<span class="rating-stars ${className}" title="Rating: ${rating}/5">${stars}${ratingText}</span>`;
                },
                
                getRatingColor: function(rating) {
                    if (rating >= 4.5) return 'text-green-600';
                    if (rating >= 3.5) return 'text-yellow-600';
                    if (rating >= 2.5) return 'text-orange-600';
                    return 'text-red-600';
                },
                
                getRatingStats: function(ratings) {
                    if (!ratings || ratings.length === 0) {
                        return { average: 0, total: 0, distribution: [0,0,0,0,0] };
                    }
                    
                    const distribution = [0,0,0,0,0]; // 1-star to 5-star counts
                    ratings.forEach(rating => {
                        if (rating.rating >= 1 && rating.rating <= 5) {
                            distribution[rating.rating - 1]++;
                        }
                    });
                    
                    return {
                        average: this.calculateAverageRating(ratings),
                        total: ratings.length,
                        distribution: distribution
                    };
                }
            };
            
            // Featured product utilities
            const FeaturedUtils = {
                isFeatured: function(product) {
                    return product.featured && !this.isFeaturedExpired(product);
                },
                
                isFeaturedExpired: function(product) {
                    if (!product.featured || !product.featuredExpiry) return true;
                    return DateUtils.isExpired(product.featuredExpiry);
                },
                
                getFeaturedExpiryStatus: function(product) {
                    if (!product.featured) return null;
                    if (!product.featuredExpiry) return { status: 'expired', text: 'No expiry set', color: 'red' };
                    
                    const daysLeft = DateUtils.getDaysUntilExpiry(product.featuredExpiry);
                    if (daysLeft < 0) return { status: 'expired', text: 'Expired', color: 'red' };
                    if (daysLeft <= 3) return { status: 'expiring', text: `${daysLeft} days left`, color: 'red' };
                    if (daysLeft <= 7) return { status: 'warning', text: `${daysLeft} days left`, color: 'yellow' };
                    return { status: 'active', text: `${daysLeft} days left`, color: 'green' };
                },
                
                setFeatured: function(product, days = 30) {
                    product.featured = true;
                    product.featuredExpiry = DateUtils.addDays(new Date(), days).toISOString();
                    return product;
                },
                
                removeFeatured: function(product) {
                    product.featured = false;
                    product.featuredExpiry = null;
                    return product;
                },
                
                cleanupExpiredFeatured: function(products) {
                    return products.map(product => {
                        if (product.featured && this.isFeaturedExpired(product)) {
                            product.featured = false;
                        }
                        return product;
                    });
                }
            };
            
            // User permission utilities
            const PermissionUtils = {
                canEditMerchant: function(user, merchantId) {
                    if (!user) return false;
                    if (user.role === 'admin') return true;
                    if (user.role === 'merchant' && user.merchantId === merchantId) return true;
                    return false;
                },
                
                canEditProduct: function(user, product, merchants) {
                    if (!user || !product) return false;
                    if (user.role === 'admin') return true;
                    if (user.role === 'merchant') {
                        const merchant = merchants.find(m => m.id === product.merchantId);
                        return merchant && user.merchantId === merchant.id;
                    }
                    return false;
                },
                
                canDeleteUser: function(user, targetUser) {
                    if (!user || !targetUser) return false;
                    if (user.role === 'admin' && targetUser.role !== 'admin') return true;
                    return false;
                },
                
                canModerateRatings: function(user) {
                    return user && user.role === 'admin';
                },
                
                canViewAnalytics: function(user) {
                    return user && (user.role === 'admin' || user.role === 'merchant');
                },
                
                getVisibleSections: function(user) {
                    const sections = {
                        dashboard: true,
                        merchants: false,
                        products: false,
                        users: false,
                        ratings: false,
                        analytics: false,
                        settings: false
                    };
                    
                    if (!user) return sections;
                    
                    switch (user.role) {
                        case 'admin':
                            return {
                                dashboard: true,
                                merchants: true,
                                products: true,
                                users: true,
                                ratings: true,
                                analytics: true,
                                settings: true
                            };
                        case 'merchant':
                            return {
                                dashboard: true,
                                merchants: false,
                                products: true,
                                users: false,
                                ratings: true,
                                analytics: true,
                                settings: false
                            };
                        default:
                            return sections;
                    }
                }
            };
            
            // Search and filter utilities
            const FilterUtils = {
                searchItems: function(items, searchTerm, fields) {
                    if (!searchTerm) return items;
                    const term = searchTerm.toLowerCase();
                    
                    return items.filter(item => {
                        return fields.some(field => {
                            const value = this.getNestedValue(item, field);
                            return value && value.toString().toLowerCase().includes(term);
                        });
                    });
                },
                
                getNestedValue: function(obj, path) {
                    return path.split('.').reduce((current, key) => current && current[key], obj);
                },
                
                filterByStatus: function(items, status) {
                    if (!status) return items;
                    return items.filter(item => item.status === status);
                },
                
                filterByCategory: function(items, category) {
                    if (!category) return items;
                    return items.filter(item => item.category === category);
                },
                
                filterByDateRange: function(items, startDate, endDate, dateField = 'created') {
                    if (!startDate && !endDate) return items;
                    
                    return items.filter(item => {
                        const itemDate = new Date(item[dateField]);
                        if (startDate && itemDate < new Date(startDate)) return false;
                        if (endDate && itemDate > new Date(endDate)) return false;
                        return true;
                    });
                },
                
                sortItems: function(items, field, direction = 'asc') {
                    return [...items].sort((a, b) => {
                        const aVal = this.getNestedValue(a, field);
                        const bVal = this.getNestedValue(b, field);
                        
                        if (aVal < bVal) return direction === 'asc' ? -1 : 1;
                        if (aVal > bVal) return direction === 'asc' ? 1 : -1;
                        return 0;
                    });
                }
            };
            
            // Export/Import utilities
            const DataUtils = {
                exportToJSON: function(data, filename) {
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    this.downloadBlob(blob, filename);
                },
                
                exportToCSV: function(data, headers, filename) {
                    let csv = headers.join(',') + '\n';
                    data.forEach(row => {
                        const values = headers.map(header => {
                            const value = row[header] || '';
                            return `"${value.toString().replace(/"/g, '""')}"`;
                        });
                        csv += values.join(',') + '\n';
                    });
                    
                    const blob = new Blob([csv], { type: 'text/csv' });
                    this.downloadBlob(blob, filename);
                },
                
                downloadBlob: function(blob, filename) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },
                
                generateId: function(existingItems = []) {
                    if (existingItems.length === 0) return 1;
                    const maxId = Math.max(...existingItems.map(item => item.id || 0));
                    return maxId + 1;
                },
                
                validateImportData: function(data, requiredFields) {
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid data format');
                    }
                    
                    for (const field of requiredFields) {
                        if (!(field in data)) {
                            throw new Error(`Missing required field: ${field}`);
                        }
                    }
                    
                    return true;
                },
                
                mergeData: function(existing, imported, mergeStrategy = 'append') {
                    switch (mergeStrategy) {
                        case 'replace':
                            return imported;
                        case 'append':
                            return [...existing, ...imported];
                        case 'merge':
                            const merged = [...existing];
                            imported.forEach(importedItem => {
                                const existingIndex = merged.findIndex(item => item.id === importedItem.id);
                                if (existingIndex >= 0) {
                                    merged[existingIndex] = { ...merged[existingIndex], ...importedItem };
                                } else {
                                    merged.push(importedItem);
                                }
                            });
                            return merged;
                        default:
                            return existing;
                    }
                }
            };
            
            // Notification utilities
            const NotificationUtils = {
                show: function(message, type = 'info', duration = 5000) {
                    const notification = document.createElement('div');
                    notification.className = `notification ${type} fixed top-4 right-4 z-50 max-w-sm`;
                    notification.innerHTML = `
                        <div class="bg-white border-l-4 border-${this.getColorClass(type)} rounded-lg shadow-lg p-4">
                            <div class="flex items-start">
                                <div class="flex-shrink-0">
                                    ${this.getIcon(type)}
                                </div>
                                <div class="ml-3 flex-1">
                                    <p class="text-sm text-gray-800">${message}</p>
                                </div>
                                <button onclick="this.parentElement.parentElement.parentElement.remove()" class="ml-2 text-gray-400 hover:text-gray-600">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(notification);
                    
                    // Auto-remove after duration
                    setTimeout(() => {
                        if (notification.parentElement) {
                            notification.remove();
                        }
                    }, duration);
                    
                    return notification;
                },
                
                getColorClass: function(type) {
                    const colors = {
                        success: 'green-500',
                        error: 'red-500',
                        warning: 'yellow-500',
                        info: 'blue-500'
                    };
                    return colors[type] || colors.info;
                },
                
                getIcon: function(type) {
                    const icons = {
                        success: '<svg class="w-5 h-5 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>',
                        error: '<svg class="w-5 h-5 text-red-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>',
                        warning: '<svg class="w-5 h-5 text-yellow-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>',
                        info: '<svg class="w-5 h-5 text-blue-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>'
                    };
                    return icons[type] || icons.info;
                }
            };
            
            // Analytics utilities
            const AnalyticsUtils = {
                calculateGrowthRate: function(current, previous) {
                    if (previous === 0) return current > 0 ? 100 : 0;
                    return Math.round(((current - previous) / previous) * 100);
                },
                
                getTopItems: function(items, field, limit = 5) {
                    return items
                        .sort((a, b) => (b[field] || 0) - (a[field] || 0))
                        .slice(0, limit);
                },
                
                groupByPeriod: function(items, dateField, period = 'month') {
                    const groups = {};
                    
                    items.forEach(item => {
                        const date = new Date(item[dateField]);
                        let key;
                        
                        switch (period) {
                            case 'day':
                                key = date.toISOString().split('T')[0];
                                break;
                            case 'week':
                                const weekStart = new Date(date);
                                weekStart.setDate(date.getDate() - date.getDay());
                                key = weekStart.toISOString().split('T')[0];
                                break;
                            case 'month':
                                key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                                break;
                            case 'year':
                                key = date.getFullYear().toString();
                                break;
                            default:
                                key = date.toISOString().split('T')[0];
                        }
                        
                        if (!groups[key]) groups[key] = [];
                        groups[key].push(item);
                    });
                    
                    return groups;
                },
                
                calculateStats: function(numbers) {
                    if (!numbers || numbers.length === 0) {
                        return { min: 0, max: 0, avg: 0, sum: 0, count: 0 };
                    }
                    
                    const sum = numbers.reduce((acc, num) => acc + num, 0);
                    return {
                        min: Math.min(...numbers),
                        max: Math.max(...numbers),
                        avg: Math.round((sum / numbers.length) * 100) / 100,
                        sum: sum,
                        count: numbers.length
                    };
                }
            };
            
            // Public API
            return {
                // Expose utility modules
                DataValidator,
                DateUtils,
                RatingUtils,
                FeaturedUtils,
                PermissionUtils,
                FilterUtils,
                DataUtils,
                NotificationUtils,
                AnalyticsUtils,
                
                // Convenience methods
                formatCurrency: function(amount, currency = 'ZAR') {
                    const symbol = currency === 'ZAR' ? 'R' : currency;
                    return `${symbol}${amount.toFixed(2)}`;
                },
                
                truncateText: function(text, maxLength = 100) {
                    if (!text || text.length <= maxLength) return text;
                    return text.substring(0, maxLength) + '...';
                },
                
                generateSlug: function(text) {
                    return text.toLowerCase()
                              .replace(/[^a-z0-9 -]/g, '')
                              .replace(/\s+/g, '-')
                              .replace(/-+/g, '-')
                              .trim('-');
                },
                
                debounce: function(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                },
                
                // Version info
                version: '5.1',
                build: '2024-07-13'
            };
        })();
        
        // Auto-initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                console.log('üîß TokenZ Admin Utilities v5.1 loaded');
            });
        } else {
            console.log('üîß TokenZ Admin Utilities v5.1 loaded');
        }
        
        // Export for Node.js environments (if needed)
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = window.TokenZUtils;
        }
    </script>
</body>
</html>
