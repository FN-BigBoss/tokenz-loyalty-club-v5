
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TokenZ Admin Utilities v5.1</title>
</head>
<body>
<script>
// TokenZ Admin Utilities Module v5.1
// This module contains utility functions for the admin system

// Enhanced data structure with new features
const AdminDataStructure = {
    merchants: [],
    products: [],
    users: [],
    ratings: [], // New: All ratings and reviews
    featuredProducts: [], // New: Featured product tracking
    userFollows: [], // New: User-merchant follow relationships
    categories: {
        merchant: [],
        product: []
    },
    recentActivity: []
};

// Rating and Review Management
const RatingUtils = {
    // Add a new rating
    addRating: function(userId, productId, rating, review = '') {
        const newRating = {
            id: this.generateRatingId(),
            userId: userId,
            productId: productId,
            merchantId: this.getProductMerchantId(productId),
            rating: rating,
            review: review.trim(),
            date: new Date().toISOString(),
            status: 'active', // active, hidden, flagged
            helpful: 0 // helpful votes
        };
        
        if (!window.adminData.ratings) {
            window.adminData.ratings = [];
        }
        
        window.adminData.ratings.push(newRating);
        this.updateProductRating(productId);
        return newRating;
    },
    
    // Update product average rating
    updateProductRating: function(productId) {
        const productRatings = window.adminData.ratings.filter(r => 
            r.productId === productId && r.status === 'active'
        );
        
        if (productRatings.length === 0) return;
        
        const average = productRatings.reduce((sum, r) => sum + r.rating, 0) / productRatings.length;
        const product = window.adminData.products.find(p => p.id === productId);
        
        if (product) {
            product.averageRating = Math.round(average * 10) / 10;
            product.ratingCount = productRatings.length;
        }
    },
    
    // Get product merchant ID
    getProductMerchantId: function(productId) {
        const product = window.adminData.products.find(p => p.id === productId);
        return product ? product.merchantId : null;
    },
    
    // Generate unique rating ID
    generateRatingId: function() {
        const existingIds = window.adminData.ratings ? window.adminData.ratings.map(r => r.id) : [];
        return Math.max(...existingIds, 0) + 1;
    },
    
    // Get ratings for a product
    getProductRatings: function(productId) {
        return window.adminData.ratings ? 
            window.adminData.ratings.filter(r => r.productId === productId) : [];
    },
    
    // Get ratings by a user
    getUserRatings: function(userId) {
        return window.adminData.ratings ? 
            window.adminData.ratings.filter(r => r.userId === userId) : [];
    },
    
    // Moderate rating (hide/show)
    moderateRating: function(ratingId, status) {
        const rating = window.adminData.ratings.find(r => r.id === ratingId);
        if (rating) {
            rating.status = status;
            this.updateProductRating(rating.productId);
        }
    },
    
    // Delete rating
    deleteRating: function(ratingId) {
        const ratingIndex = window.adminData.ratings.findIndex(r => r.id === ratingId);
        if (ratingIndex !== -1) {
            const rating = window.adminData.ratings[ratingIndex];
            window.adminData.ratings.splice(ratingIndex, 1);
            this.updateProductRating(rating.productId);
        }
    },
    
    // Generate star display HTML
    generateStarDisplay: function(rating, showNumber = true) {
        const fullStars = Math.floor(rating);
        const hasHalfStar = rating % 1 >= 0.5;
        const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);
        
        let html = '<div class="flex items-center space-x-1">';
        
        // Full stars
        for (let i = 0; i < fullStars; i++) {
            html += '<svg class="w-4 h-4 text-yellow-400 fill-current" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"/></svg>';
        }
        
        // Half star
        if (hasHalfStar) {
            html += '<svg class="w-4 h-4 text-yellow-400" viewBox="0 0 20 20"><defs><linearGradient id="half"><stop offset="50%" stop-color="currentColor"/><stop offset="50%" stop-color="transparent"/></linearGradient></defs><path fill="url(#half)" d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"/></svg>';
        }
        
        // Empty stars
        for (let i = 0; i < emptyStars; i++) {
            html += '<svg class="w-4 h-4 text-gray-300" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"/></svg>';
        }
        
        if (showNumber) {
            html += `<span class="text-sm text-gray-600 ml-1">(${rating.toFixed(1)})</span>`;
        }
        
        html += '</div>';
        return html;
    }
};

// Featured Products Management
const FeaturedUtils = {
    // Add product to featured list
    addFeatured: function(productId, expiryDays = 30) {
        const expiryDate = new Date();
        expiryDate.setDate(expiryDate.getDate() + expiryDays);
        
        const featured = {
            id: this.generateFeaturedId(),
            productId: productId,
            startDate: new Date().toISOString(),
            expiryDate: expiryDate.toISOString(),
            status: 'active',
            addedBy: 'admin' // Could be 'admin' or 'merchant'
        };
        
        if (!window.adminData.featuredProducts) {
            window.adminData.featuredProducts = [];
        }
        
        // Remove existing featured entry for this product
        window.adminData.featuredProducts = window.adminData.featuredProducts.filter(f => f.productId !== productId);
        
        // Add new featured entry
        window.adminData.featuredProducts.push(featured);
        
        // Update product featured status
        const product = window.adminData.products.find(p => p.id === productId);
        if (product) {
            product.featured = true;
            product.featuredExpiry = expiryDate.toISOString();
        }
        
        return featured;
    },
    
    // Remove product from featured list
    removeFeatured: function(productId) {
        window.adminData.featuredProducts = window.adminData.featuredProducts.filter(f => f.productId !== productId);
        
        const product = window.adminData.products.find(p => p.id === productId);
        if (product) {
            product.featured = false;
            product.featuredExpiry = null;
        }
    },
    
    // Check and clean expired featured products
    cleanExpiredFeatured: function() {
        const now = new Date();
        const expired = [];
        
        window.adminData.featuredProducts = window.adminData.featuredProducts.filter(featured => {
            const expiryDate = new Date(featured.expiryDate);
            if (expiryDate <= now) {
                expired.push(featured);
                
                // Update product status
                const product = window.adminData.products.find(p => p.id === featured.productId);
                if (product) {
                    product.featured = false;
                    product.featuredExpiry = null;
                }
                
                return false;
            }
            return true;
        });
        
        return expired;
    },
    
    // Get active featured products
    getActiveFeatured: function() {
        this.cleanExpiredFeatured();
        return window.adminData.featuredProducts.filter(f => f.status === 'active');
    },
    
    // Generate unique featured ID
    generateFeaturedId: function() {
        const existingIds = window.adminData.featuredProducts ? 
            window.adminData.featuredProducts.map(f => f.id) : [];
        return Math.max(...existingIds, 0) + 1;
    },
    
    // Get days remaining for featured product
    getDaysRemaining: function(featuredItem) {
        const now = new Date();
        const expiry = new Date(featuredItem.expiryDate);
        const diffTime = expiry - now;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return Math.max(0, diffDays);
    }
};

// User Follow System
const FollowUtils = {
    // Add user follow relationship
    addFollow: function(userId, merchantId) {
        if (!window.adminData.userFollows) {
            window.adminData.userFollows = [];
        }
        
        const existingFollow = window.adminData.userFollows.find(f => 
            f.userId === userId && f.merchantId === merchantId
        );
        
        if (!existingFollow) {
            window.adminData.userFollows.push({
                id: this.generateFollowId(),
                userId: userId,
                merchantId: merchantId,
                followDate: new Date().toISOString(),
                status: 'active'
            });
        }
    },
    
    // Remove user follow relationship
    removeFollow: function(userId, merchantId) {
        window.adminData.userFollows = window.adminData.userFollows.filter(f => 
            !(f.userId === userId && f.merchantId === merchantId)
        );
    },
    
    // Get followers for a merchant
    getMerchantFollowers: function(merchantId) {
        return window.adminData.userFollows ? 
            window.adminData.userFollows.filter(f => f.merchantId === merchantId && f.status === 'active') : [];
    },
    
    // Get merchants followed by user
    getUserFollows: function(userId) {
        return window.adminData.userFollows ? 
            window.adminData.userFollows.filter(f => f.userId === userId && f.status === 'active') : [];
    },
    
    // Check if user follows merchant
    isFollowing: function(userId, merchantId) {
        return window.adminData.userFollows ? 
            window.adminData.userFollows.some(f => 
                f.userId === userId && f.merchantId === merchantId && f.status === 'active'
            ) : false;
    },
    
    // Generate unique follow ID
    generateFollowId: function() {
        const existingIds = window.adminData.userFollows ? 
            window.adminData.userFollows.map(f => f.id) : [];
        return Math.max(...existingIds, 0) + 1;
    },
    
    // Get follower count for merchant
    getFollowerCount: function(merchantId) {
        return this.getMerchantFollowers(merchantId).length;
    }
};

// Permission and Role Management
const PermissionUtils = {
    // Check if current user has admin permissions
    isAdmin: function(user) {
        return user && user.role === 'admin';
    },
    
    // Check if current user has merchant permissions
    isMerchant: function(user) {
        return user && user.role === 'merchant';
    },
    
    // Check if current user can edit merchant
    canEditMerchant: function(user, merchantId) {
        if (this.isAdmin(user)) return true;
        if (this.isMerchant(user)) {
            // Merchants can only edit their own merchant profile
            return user.merchantId === merchantId;
        }
        return false;
    },
    
    // Check if current user can edit product
    canEditProduct: function(user, product) {
        if (this.isAdmin(user)) return true;
        if (this.isMerchant(user)) {
            // Merchants can only edit products for their merchant
            return user.merchantId === product.merchantId;
        }
        return false;
    },
    
    // Get merchant ID for current user
    getUserMerchantId: function(user) {
        if (this.isMerchant(user)) {
            return user.merchantId;
        }
        return null;
    },
    
    // Filter products by user permissions
    filterProductsByPermission: function(user, products) {
        if (this.isAdmin(user)) return products;
        if (this.isMerchant(user)) {
            return products.filter(p => p.merchantId === user.merchantId);
        }
        return [];
    },
    
    // Filter merchants by user permissions
    filterMerchantsByPermission: function(user, merchants) {
        if (this.isAdmin(user)) return merchants;
        if (this.isMerchant(user)) {
            return merchants.filter(m => m.id === user.merchantId);
        }
        return [];
    }
};

// Data Migration and Compatibility
const MigrationUtils = {
    // Migrate old data structure to new format
    migrateData: function(data) {
        console.log('🔄 Migrating data to v5.1 format...');
        
        // Initialize new collections if they don't exist
        if (!data.ratings) data.ratings = [];
        if (!data.featuredProducts) data.featuredProducts = [];
        if (!data.userFollows) data.userFollows = [];
        
        // Migrate products to include rating fields
        data.products.forEach(product => {
            if (typeof product.averageRating === 'undefined') {
                product.averageRating = 0;
                product.ratingCount = 0;
            }
            if (typeof product.featured === 'undefined') {
                product.featured = false;
                product.featuredExpiry = null;
            }
        });
        
        // Migrate users to include follow relationships
        data.users.forEach(user => {
            if (!user.followedMerchants) {
                user.followedMerchants = [];
            }
            if (!user.role) {
                user.role = 'member';
            }
        });
        
        // Migrate merchants to include follower tracking
        data.merchants.forEach(merchant => {
            if (typeof merchant.followerCount === 'undefined') {
                merchant.followerCount = 0;
            }
        });
        
        console.log('✅ Data migration complete');
        return data;
    },
    
    // Validate data integrity
    validateData: function(data) {
        const issues = [];
        
        // Check for orphaned ratings
        data.ratings.forEach(rating => {
            const product = data.products.find(p => p.id === rating.productId);
            const user = data.users.find(u => u.id === rating.userId);
            
            if (!product) issues.push(`Rating ${rating.id} references non-existent product ${rating.productId}`);
            if (!user) issues.push(`Rating ${rating.id} references non-existent user ${rating.userId}`);
        });
        
        // Check for orphaned featured products
        data.featuredProducts.forEach(featured => {
            const product = data.products.find(p => p.id === featured.productId);
            if (!product) issues.push(`Featured entry ${featured.id} references non-existent product ${featured.productId}`);
        });
        
        // Check for orphaned follows
        data.userFollows.forEach(follow => {
            const user = data.users.find(u => u.id === follow.userId);
            const merchant = data.merchants.find(m => m.id === follow.merchantId);
            
            if (!user) issues.push(`Follow ${follow.id} references non-existent user ${follow.userId}`);
            if (!merchant) issues.push(`Follow ${follow.id} references non-existent merchant ${follow.merchantId}`);
        });
        
        return issues;
    },
    
    // Clean orphaned data
    cleanOrphanedData: function(data) {
        console.log('🧹 Cleaning orphaned data...');
        
        // Remove orphaned ratings
        data.ratings = data.ratings.filter(rating => {
            const product = data.products.find(p => p.id === rating.productId);
            const user = data.users.find(u => u.id === rating.userId);
            return product && user;
        });
        
        // Remove orphaned featured products
        data.featuredProducts = data.featuredProducts.filter(featured => {
            const product = data.products.find(p => p.id === featured.productId);
            return product;
        });
        
        // Remove orphaned follows
        data.userFollows = data.userFollows.filter(follow => {
            const user = data.users.find(u => u.id === follow.userId);
            const merchant = data.merchants.find(m => m.id === follow.merchantId);
            return user && merchant;
        });
        
        console.log('✅ Orphaned data cleaned');
        return data;
    }
};

// Export utilities to global scope
window.AdminUtils = {
    Rating: RatingUtils,
    Featured: FeaturedUtils,
    Follow: FollowUtils,
    Permission: PermissionUtils,
    Migration: MigrationUtils
};

console.log('✅ Admin Utilities v5.1 loaded successfully');
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TokenZ Admin Utilities v5.1</title>
    <style>
        /* This module provides utility functions for the TokenZ Admin System */
        .utility-module { display: none; }
    </style>
</head>
<body class="utility-module">
    <script>
        // TokenZ Admin Utilities Module v5.1
        // Utility functions separated from main admin interface for better organization
        
        window.TokenZUtils = (function() {
            'use strict';
            
            // Data validation utilities
            const DataValidator = {
                validateEmail: function(email) {
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    return emailRegex.test(email);
                },
                
                validateUrl: function(url) {
                    try {
                        new URL(url);
                        return true;
                    } catch {
                        return false;
                    }
                },
                
                validatePrice: function(price) {
                    return !isNaN(price) && parseFloat(price) >= 0;
                },
                
                validateRating: function(rating) {
                    const num = parseInt(rating);
                    return !isNaN(num) && num >= 1 && num <= 5;
                },
                
                sanitizeText: function(text) {
                    if (!text) return '';
                    return text.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                              .replace(/[<>]/g, '');
                }
            };
            
            // Date utilities
            const DateUtils = {
                formatDate: function(dateString) {
                    if (!dateString) return 'N/A';
                    const date = new Date(dateString);
                    return date.toLocaleDateString('en-ZA', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    });
                },
                
                formatDateTime: function(dateString) {
                    if (!dateString) return 'N/A';
                    const date = new Date(dateString);
                    return date.toLocaleString('en-ZA', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                },
                
                getTimeAgo: function(dateString) {
                    if (!dateString) return 'Unknown';
                    const now = new Date();
                    const date = new Date(dateString);
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / (1000 * 60));
                    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                    
                    if (diffMins < 1) return 'Just now';
                    if (diffMins < 60) return `${diffMins} min${diffMins > 1 ? 's' : ''} ago`;
                    if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
                    if (diffDays < 30) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
                    return this.formatDate(dateString);
                },
                
                addDays: function(date, days) {
                    const result = new Date(date);
                    result.setDate(result.getDate() + days);
                    return result;
                },
                
                isExpired: function(dateString) {
                    if (!dateString) return false;
                    return new Date(dateString) < new Date();
                },
                
                getDaysUntilExpiry: function(dateString) {
                    if (!dateString) return null;
                    const expiry = new Date(dateString);
                    const now = new Date();
                    const diffTime = expiry - now;
                    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                }
            };
            
            // Rating utilities
            const RatingUtils = {
                calculateAverageRating: function(ratings) {
                    if (!ratings || ratings.length === 0) return 0;
                    const sum = ratings.reduce((acc, rating) => acc + rating.rating, 0);
                    return Math.round((sum / ratings.length) * 10) / 10; // Round to 1 decimal
                },
                
                generateStarDisplay: function(rating, maxStars = 5) {
                    const fullStars = Math.floor(rating);
                    const hasHalfStar = rating % 1 >= 0.5;
                    const emptyStars = maxStars - fullStars - (hasHalfStar ? 1 : 0);
                    
                    let stars = '';
                    for (let i = 0; i < fullStars; i++) stars += '★';
                    if (hasHalfStar) stars += '☆';
                    for (let i = 0; i < emptyStars; i++) stars += '☆';
                    
                    return stars;
                },
                
                generateStarHTML: function(rating, showNumber = true, className = '') {
                    const stars = this.generateStarDisplay(rating);
                    const ratingText = showNumber ? ` (${rating})` : '';
                    return `<span class="rating-stars ${className}" title="Rating: ${rating}/5">${stars}${ratingText}</span>`;
                },
                
                getRatingColor: function(rating) {
                    if (rating >= 4.5) return 'text-green-600';
                    if (rating >= 3.5) return 'text-yellow-600';
                    if (rating >= 2.5) return 'text-orange-600';
                    return 'text-red-600';
                },
                
                getRatingStats: function(ratings) {
                    if (!ratings || ratings.length === 0) {
                        return { average: 0, total: 0, distribution: [0,0,0,0,0] };
                    }
                    
                    const distribution = [0,0,0,0,0]; // 1-star to 5-star counts
                    ratings.forEach(rating => {
                        if (rating.rating >= 1 && rating.rating <= 5) {
                            distribution[rating.rating - 1]++;
                        }
                    });
                    
                    return {
                        average: this.calculateAverageRating(ratings),
                        total: ratings.length,
                        distribution: distribution
                    };
                }
            };
            
            // Featured product utilities
            const FeaturedUtils = {
                isFeatured: function(product) {
                    return product.featured && !this.isFeaturedExpired(product);
                },
                
                isFeaturedExpired: function(product) {
                    if (!product.featured || !product.featuredExpiry) return true;
                    return DateUtils.isExpired(product.featuredExpiry);
                },
                
                getFeaturedExpiryStatus: function(product) {
                    if (!product.featured) return null;
                    if (!product.featuredExpiry) return { status: 'expired', text: 'No expiry set', color: 'red' };
                    
                    const daysLeft = DateUtils.getDaysUntilExpiry(product.featuredExpiry);
                    if (daysLeft < 0) return { status: 'expired', text: 'Expired', color: 'red' };
                    if (daysLeft <= 3) return { status: 'expiring', text: `${daysLeft} days left`, color: 'red' };
                    if (daysLeft <= 7) return { status: 'warning', text: `${daysLeft} days left`, color: 'yellow' };
                    return { status: 'active', text: `${daysLeft} days left`, color: 'green' };
                },
                
                setFeatured: function(product, days = 30) {
                    product.featured = true;
                    product.featuredExpiry = DateUtils.addDays(new Date(), days).toISOString();
                    return product;
                },
                
                removeFeatured: function(product) {
                    product.featured = false;
                    product.featuredExpiry = null;
                    return product;
                },
                
                cleanupExpiredFeatured: function(products) {
                    return products.map(product => {
                        if (product.featured && this.isFeaturedExpired(product)) {
                            product.featured = false;
                        }
                        return product;
                    });
                }
            };
            
            // User permission utilities
            const PermissionUtils = {
                canEditMerchant: function(user, merchantId) {
                    if (!user) return false;
                    if (user.role === 'admin') return true;
                    if (user.role === 'merchant' && user.merchantId === merchantId) return true;
                    return false;
                },
                
                canEditProduct: function(user, product, merchants) {
                    if (!user || !product) return false;
                    if (user.role === 'admin') return true;
                    if (user.role === 'merchant') {
                        const merchant = merchants.find(m => m.id === product.merchantId);
                        return merchant && user.merchantId === merchant.id;
                    }
                    return false;
                },
                
                canDeleteUser: function(user, targetUser) {
                    if (!user || !targetUser) return false;
                    if (user.role === 'admin' && targetUser.role !== 'admin') return true;
                    return false;
                },
                
                canModerateRatings: function(user) {
                    return user && user.role === 'admin';
                },
                
                canViewAnalytics: function(user) {
                    return user && (user.role === 'admin' || user.role === 'merchant');
                },
                
                getVisibleSections: function(user) {
                    const sections = {
                        dashboard: true,
                        merchants: false,
                        products: false,
                        users: false,
                        ratings: false,
                        analytics: false,
                        settings: false
                    };
                    
                    if (!user) return sections;
                    
                    switch (user.role) {
                        case 'admin':
                            return {
                                dashboard: true,
                                merchants: true,
                                products: true,
                                users: true,
                                ratings: true,
                                analytics: true,
                                settings: true
                            };
                        case 'merchant':
                            return {
                                dashboard: true,
                                merchants: false,
                                products: true,
                                users: false,
                                ratings: true,
                                analytics: true,
                                settings: false
                            };
                        default:
                            return sections;
                    }
                }
            };
            
            // Search and filter utilities
            const FilterUtils = {
                searchItems: function(items, searchTerm, fields) {
                    if (!searchTerm) return items;
                    const term = searchTerm.toLowerCase();
                    
                    return items.filter(item => {
                        return fields.some(field => {
                            const value = this.getNestedValue(item, field);
                            return value && value.toString().toLowerCase().includes(term);
                        });
                    });
                },
                
                getNestedValue: function(obj, path) {
                    return path.split('.').reduce((current, key) => current && current[key], obj);
                },
                
                filterByStatus: function(items, status) {
                    if (!status) return items;
                    return items.filter(item => item.status === status);
                },
                
                filterByCategory: function(items, category) {
                    if (!category) return items;
                    return items.filter(item => item.category === category);
                },
                
                filterByDateRange: function(items, startDate, endDate, dateField = 'created') {
                    if (!startDate && !endDate) return items;
                    
                    return items.filter(item => {
                        const itemDate = new Date(item[dateField]);
                        if (startDate && itemDate < new Date(startDate)) return false;
                        if (endDate && itemDate > new Date(endDate)) return false;
                        return true;
                    });
                },
                
                sortItems: function(items, field, direction = 'asc') {
                    return [...items].sort((a, b) => {
                        const aVal = this.getNestedValue(a, field);
                        const bVal = this.getNestedValue(b, field);
                        
                        if (aVal < bVal) return direction === 'asc' ? -1 : 1;
                        if (aVal > bVal) return direction === 'asc' ? 1 : -1;
                        return 0;
                    });
                }
            };
            
            // Export/Import utilities
            const DataUtils = {
                exportToJSON: function(data, filename) {
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    this.downloadBlob(blob, filename);
                },
                
                exportToCSV: function(data, headers, filename) {
                    let csv = headers.join(',') + '\n';
                    data.forEach(row => {
                        const values = headers.map(header => {
                            const value = row[header] || '';
                            return `"${value.toString().replace(/"/g, '""')}"`;
                        });
                        csv += values.join(',') + '\n';
                    });
                    
                    const blob = new Blob([csv], { type: 'text/csv' });
                    this.downloadBlob(blob, filename);
                },
                
                downloadBlob: function(blob, filename) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },
                
                generateId: function(existingItems = []) {
                    if (existingItems.length === 0) return 1;
                    const maxId = Math.max(...existingItems.map(item => item.id || 0));
                    return maxId + 1;
                },
                
                validateImportData: function(data, requiredFields) {
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid data format');
                    }
                    
                    for (const field of requiredFields) {
                        if (!(field in data)) {
                            throw new Error(`Missing required field: ${field}`);
                        }
                    }
                    
                    return true;
                },
                
                mergeData: function(existing, imported, mergeStrategy = 'append') {
                    switch (mergeStrategy) {
                        case 'replace':
                            return imported;
                        case 'append':
                            return [...existing, ...imported];
                        case 'merge':
                            const merged = [...existing];
                            imported.forEach(importedItem => {
                                const existingIndex = merged.findIndex(item => item.id === importedItem.id);
                                if (existingIndex >= 0) {
                                    merged[existingIndex] = { ...merged[existingIndex], ...importedItem };
                                } else {
                                    merged.push(importedItem);
                                }
                            });
                            return merged;
                        default:
                            return existing;
                    }
                }
            };
            
            // Notification utilities
            const NotificationUtils = {
                show: function(message, type = 'info', duration = 5000) {
                    const notification = document.createElement('div');
                    notification.className = `notification ${type} fixed top-4 right-4 z-50 max-w-sm`;
                    notification.innerHTML = `
                        <div class="bg-white border-l-4 border-${this.getColorClass(type)} rounded-lg shadow-lg p-4">
                            <div class="flex items-start">
                                <div class="flex-shrink-0">
                                    ${this.getIcon(type)}
                                </div>
                                <div class="ml-3 flex-1">
                                    <p class="text-sm text-gray-800">${message}</p>
                                </div>
                                <button onclick="this.parentElement.parentElement.parentElement.remove()" class="ml-2 text-gray-400 hover:text-gray-600">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(notification);
                    
                    // Auto-remove after duration
                    setTimeout(() => {
                        if (notification.parentElement) {
                            notification.remove();
                        }
                    }, duration);
                    
                    return notification;
                },
                
                getColorClass: function(type) {
                    const colors = {
                        success: 'green-500',
                        error: 'red-500',
                        warning: 'yellow-500',
                        info: 'blue-500'
                    };
                    return colors[type] || colors.info;
                },
                
                getIcon: function(type) {
                    const icons = {
                        success: '<svg class="w-5 h-5 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>',
                        error: '<svg class="w-5 h-5 text-red-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>',
                        warning: '<svg class="w-5 h-5 text-yellow-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>',
                        info: '<svg class="w-5 h-5 text-blue-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>'
                    };
                    return icons[type] || icons.info;
                }
            };
            
            // Analytics utilities
            const AnalyticsUtils = {
                calculateGrowthRate: function(current, previous) {
                    if (previous === 0) return current > 0 ? 100 : 0;
                    return Math.round(((current - previous) / previous) * 100);
                },
                
                getTopItems: function(items, field, limit = 5) {
                    return items
                        .sort((a, b) => (b[field] || 0) - (a[field] || 0))
                        .slice(0, limit);
                },
                
                groupByPeriod: function(items, dateField, period = 'month') {
                    const groups = {};
                    
                    items.forEach(item => {
                        const date = new Date(item[dateField]);
                        let key;
                        
                        switch (period) {
                            case 'day':
                                key = date.toISOString().split('T')[0];
                                break;
                            case 'week':
                                const weekStart = new Date(date);
                                weekStart.setDate(date.getDate() - date.getDay());
                                key = weekStart.toISOString().split('T')[0];
                                break;
                            case 'month':
                                key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                                break;
                            case 'year':
                                key = date.getFullYear().toString();
                                break;
                            default:
                                key = date.toISOString().split('T')[0];
                        }
                        
                        if (!groups[key]) groups[key] = [];
                        groups[key].push(item);
                    });
                    
                    return groups;
                },
                
                calculateStats: function(numbers) {
                    if (!numbers || numbers.length === 0) {
                        return { min: 0, max: 0, avg: 0, sum: 0, count: 0 };
                    }
                    
                    const sum = numbers.reduce((acc, num) => acc + num, 0);
                    return {
                        min: Math.min(...numbers),
                        max: Math.max(...numbers),
                        avg: Math.round((sum / numbers.length) * 100) / 100,
                        sum: sum,
                        count: numbers.length
                    };
                }
            };
            
            // Public API
            return {
                // Expose utility modules
                DataValidator,
                DateUtils,
                RatingUtils,
                FeaturedUtils,
                PermissionUtils,
                FilterUtils,
                DataUtils,
                NotificationUtils,
                AnalyticsUtils,
                
                // Convenience methods
                formatCurrency: function(amount, currency = 'ZAR') {
                    const symbol = currency === 'ZAR' ? 'R' : currency;
                    return `${symbol}${amount.toFixed(2)}`;
                },
                
                truncateText: function(text, maxLength = 100) {
                    if (!text || text.length <= maxLength) return text;
                    return text.substring(0, maxLength) + '...';
                },
                
                generateSlug: function(text) {
                    return text.toLowerCase()
                              .replace(/[^a-z0-9 -]/g, '')
                              .replace(/\s+/g, '-')
                              .replace(/-+/g, '-')
                              .trim('-');
                },
                
                debounce: function(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                },
                
                // Version info
                version: '5.1',
                build: '2024-07-13'
            };
        })();
        
        // Auto-initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                console.log('🔧 TokenZ Admin Utilities v5.1 loaded');
            });
        } else {
            console.log('🔧 TokenZ Admin Utilities v5.1 loaded');
        }
        
        // Export for Node.js environments (if needed)
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = window.TokenZUtils;
        }
    </script>
</body>
</html>
